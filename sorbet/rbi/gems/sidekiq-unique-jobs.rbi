# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sidekiq-unique-jobs/all/sidekiq-unique-jobs.rbi
#
# sidekiq-unique-jobs-6.0.13
module SidekiqUniqueJobs
  def config; end
  def configure(options = nil); end
  def logger; end
  def logger=(other); end
  def redis_version; end
  def self.config; end
  def self.configure(options = nil); end
  def self.logger; end
  def self.logger=(other); end
  def self.redis_version; end
  def self.use_config(tmp_config); end
  def self.with_context(context, &block); end
  def use_config(tmp_config); end
  def with_context(context, &block); end
  extend SidekiqUniqueJobs::Connection
  extend SidekiqUniqueJobs::Middleware
  include SidekiqUniqueJobs::Connection
end
module SidekiqUniqueJobs::Logging
  def log_debug(message_or_exception = nil, &block); end
  def log_error(message_or_exception = nil, &block); end
  def log_fatal(message_or_exception = nil, &block); end
  def log_info(message_or_exception = nil, &block); end
  def log_warn(message_or_exception = nil, &block); end
  def logger; end
  def logging_context(middleware_class, job_hash); end
end
module SidekiqUniqueJobs::SidekiqWorkerMethods
  def after_unlock_hook; end
  def default_worker_options; end
  def sidekiq_worker_class?; end
  def worker_class; end
  def worker_class_constantize(klazz = nil); end
  def worker_method_defined?(method_sym); end
  def worker_options; end
end
module SidekiqUniqueJobs::Connection
  def redis(redis_pool = nil); end
  def self.included(base); end
end
class SidekiqUniqueJobs::Conflict < StandardError
  def initialize(item); end
end
class SidekiqUniqueJobs::ScriptError < StandardError
  def initialize(file_name:, source_exception:); end
end
class SidekiqUniqueJobs::UnknownLock < StandardError
end
module SidekiqUniqueJobs::Job
  def add_timeout_and_expiration(item); end
  def add_unique_args_and_digest(item); end
  def add_uniqueness(item); end
  extend SidekiqUniqueJobs::Job
end
module SidekiqUniqueJobs::Util
  def batch_delete(keys); end
  def current_time; end
  def del(pattern = nil, count = nil); end
  def keys(pattern = nil, count = nil); end
  def keys_with_ttl(pattern = nil, count = nil); end
  def prefix(key); end
  def suffix(key); end
  def timed; end
  def unique_prefix; end
  extend SidekiqUniqueJobs::Connection
  extend SidekiqUniqueJobs::Util
  include SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::Logging
end
module SidekiqUniqueJobs::Digests
  def all(pattern: nil, count: nil); end
  def batch_delete(digests); end
  def count; end
  def current_time; end
  def del(digest: nil, pattern: nil, count: nil); end
  def delete_by_digest(digest); end
  def delete_by_pattern(pattern, count: nil); end
  def page(pattern: nil, cursor: nil, page_size: nil); end
  def timed; end
  extend SidekiqUniqueJobs::Connection
  extend SidekiqUniqueJobs::Digests
  include SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::Logging
end
class SidekiqUniqueJobs::Cli < Thor
  def self.banner(command, _namespace = nil, _subcommand = nil); end
end
class Hash
end
class Array
end
module SidekiqUniqueJobs::Timeout
end
class SidekiqUniqueJobs::Timeout::Calculator
  def default_lock_timeout; end
  def initialize(item); end
  def item; end
  def lock_expiration; end
  def lock_timeout; end
  def scheduled_at; end
  def time_until_scheduled; end
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
module SidekiqUniqueJobs::Scripts
  def call(file_name, redis_pool, options = nil); end
  def execute_script(file_name, redis_pool, options = nil); end
  def handle_error(ex, file_name); end
  def script_path(file_name); end
  def script_sha(conn, file_name); end
  def script_source(file_name); end
  def self.call(file_name, redis_pool, options = nil); end
  def self.execute_script(file_name, redis_pool, options = nil); end
  def self.handle_error(ex, file_name); end
  def self.script_path(file_name); end
  def self.script_sha(conn, file_name); end
  def self.script_source(file_name); end
  extend SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::Connection
end
module SidekiqUniqueJobs::Normalizer
  def self.jsonify(args); end
end
class SidekiqUniqueJobs::UniqueArgs
  def add_uniqueness_to_item; end
  def create_digest; end
  def default_unique_args_method; end
  def digestable_hash; end
  def filter_by_proc(args); end
  def filter_by_symbol(args); end
  def filtered_args(args); end
  def initialize(item); end
  def item; end
  def self.digest(item); end
  def unique_across_queues?; end
  def unique_across_workers?; end
  def unique_args(args); end
  def unique_args_enabled?; end
  def unique_args_method; end
  def unique_digest; end
  def unique_prefix; end
  include SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
module SidekiqUniqueJobs::Unlockable
  def delete(item); end
  def self.delete(item); end
  def self.unlock(item); end
  def unlock(item); end
end
class SidekiqUniqueJobs::Locksmith
  def available_key; end
  def convert_legacy_lock(token); end
  def current_time; end
  def delete!; end
  def delete; end
  def exists_key; end
  def grab_token(timeout = nil); end
  def grabbed_key; end
  def initialize(item, redis_pool = nil); end
  def jid; end
  def lock(timeout = nil, &block); end
  def lock_type; end
  def locked?(token = nil); end
  def namespaced_key(variable); end
  def redis_pool; end
  def redis_time; end
  def return_token_or_block_value(token); end
  def touch_grabbed_token(token); end
  def ttl; end
  def unique_digest; end
  def unlock!(token = nil); end
  def unlock(token = nil); end
  def version_key; end
  def wait(timeout = nil, &block); end
  extend SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::Connection
end
class SidekiqUniqueJobs::Lock
end
class SidekiqUniqueJobs::Lock::BaseLock
  def add_uniqueness_when_missing; end
  def attempt; end
  def call_strategy; end
  def callback; end
  def callback_safely; end
  def delete!; end
  def delete; end
  def execute; end
  def initialize(item, callback, redis_pool = nil); end
  def item; end
  def lock; end
  def locked?; end
  def locksmith; end
  def redis_pool; end
  def replace?; end
  def strategy; end
  def unlock; end
  def unlock_with_callback; end
  def with_cleanup; end
  include SidekiqUniqueJobs::Logging
end
class SidekiqUniqueJobs::Lock::UntilExecuted < SidekiqUniqueJobs::Lock::BaseLock
  def execute; end
end
class SidekiqUniqueJobs::Lock::UntilExecuting < SidekiqUniqueJobs::Lock::BaseLock
  def execute; end
end
class SidekiqUniqueJobs::Lock::UntilExpired < SidekiqUniqueJobs::Lock::BaseLock
  def execute; end
  def unlock; end
end
class SidekiqUniqueJobs::Lock::WhileExecuting < SidekiqUniqueJobs::Lock::BaseLock
  def append_unique_key_suffix; end
  def execute; end
  def initialize(item, callback, redis_pool = nil); end
  def lock; end
end
class SidekiqUniqueJobs::Lock::WhileExecutingReject < SidekiqUniqueJobs::Lock::WhileExecuting
  def strategy; end
end
class SidekiqUniqueJobs::Lock::UntilAndWhileExecuting < SidekiqUniqueJobs::Lock::BaseLock
  def execute; end
  def runtime_lock; end
end
module SidekiqUniqueJobs::OptionsWithFallback
  def lock; end
  def lock_class; end
  def lock_type; end
  def log_duplicate_payload?; end
  def options; end
  def self.included(base); end
  def unique_disabled?; end
  def unique_enabled?; end
  def unique_type; end
end
module SidekiqUniqueJobs::Server
end
class SidekiqUniqueJobs::Server::Middleware
  def call(worker_class, item, queue); end
  def item; end
  include SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::OptionsWithFallback
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
module SidekiqUniqueJobs::Client
end
class SidekiqUniqueJobs::Client::Middleware
  def call(worker_class, item, queue, redis_pool = nil); end
  def item; end
  def locked?; end
  def success?; end
  def warn_about_duplicate; end
  include SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::OptionsWithFallback
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
module SidekiqUniqueJobs::Middleware
  def configure_client_middleware; end
  def configure_middleware; end
  def configure_server_middleware; end
  def self.extended(base); end
end
module Sidekiq
end
class Sidekiq::SortedEntry < Sidekiq::Job
  def delete_orig; end
  def remove_job_orig; end
  include Sidekiq::SortedEntry::UniqueExtension
end
module Sidekiq::SortedEntry::UniqueExtension
  def delete_ext; end
  def remove_job_ext; end
  def self.included(base); end
end
class Sidekiq::ScheduledSet < Sidekiq::JobSet
  def delete; end
  def delete_orig(score, jid); end
  include Sidekiq::ScheduledSet::UniqueExtension
end
module Sidekiq::ScheduledSet::UniqueExtension
  def delete_ext; end
  def self.included(base); end
end
class Sidekiq::Job
  def delete_orig; end
  include Sidekiq::Job::UniqueExtension
end
module Sidekiq::Job::UniqueExtension
  def delete_ext; end
  def self.included(base); end
end
class Sidekiq::Queue
  def clear_orig; end
  include Sidekiq::Queue::UniqueExtension
end
module Sidekiq::Queue::UniqueExtension
  def clear_ext; end
  def self.included(base); end
end
class Sidekiq::JobSet < Sidekiq::SortedSet
  def clear; end
  def clear_orig; end
  def delete_by_value_orig(name, value); end
  include Sidekiq::JobSet::UniqueExtension
end
module Sidekiq::JobSet::UniqueExtension
  def clear_ext; end
  def delete_by_value_ext(name, value); end
  def self.included(base); end
end
module SidekiqUniqueJobs::OnConflict
  def self.find_strategy(strategy); end
end
class SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
  def initialize(item); end
  def item; end
  def replace?; end
  include SidekiqUniqueJobs::Logging
end
class SidekiqUniqueJobs::OnConflict::NullStrategy < SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
end
class SidekiqUniqueJobs::OnConflict::Log < SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
  include SidekiqUniqueJobs::Logging
end
class SidekiqUniqueJobs::OnConflict::Raise < SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
end
class SidekiqUniqueJobs::OnConflict::Reject < SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
  def current_time; end
  def deadset; end
  def deadset_kill; end
  def deadset_kill?; end
  def kill_job_with_options; end
  def kill_job_without_options; end
  def kill_with_options?; end
  def payload; end
  def push_to_deadset; end
  def send_to_deadset; end
end
class SidekiqUniqueJobs::OnConflict::Replace < SidekiqUniqueJobs::OnConflict::Strategy
  def call(&block); end
  def delete_job_by_digest; end
  def delete_lock; end
  def initialize(item); end
  def queue; end
  def unique_digest; end
end
class SidekiqUniqueJobs::OnConflict::Reschedule < SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
  def initialize(item); end
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
class SidekiqUniqueJobs::Config < Concurrent::Synchronization::LockableObject
  def default_lock_timeout; end
  def default_lock_timeout=(value); end
  def enabled; end
  def enabled=(value); end
  def logger; end
  def logger=(value); end
  def ns_initialize(*values); end
  def self.[](*args, &block); end
  def unique_prefix; end
  def unique_prefix=(value); end
  include Concurrent::MutableStruct
end
