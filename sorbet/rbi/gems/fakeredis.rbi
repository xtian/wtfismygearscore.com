# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/fakeredis/all/fakeredis.rbi
#
# fakeredis-0.7.0
module FakeRedis
  def self.disable; end
  def self.enable; end
  def self.enabled?; end
end
module FakeRedis::CommandExecutor
  def write(command); end
end
class FakeRedis::ExpiringHash < Hash
  def [](key); end
  def []=(key, val); end
  def delete(key); end
  def expire(key); end
  def expired?(key); end
  def expires; end
  def initialize(*arg0); end
  def key?(key); end
  def keys; end
  def normalize(key); end
  def values_at(*keys); end
end
module FakeRedis::SortMethod
  def extract_options_from(options_array); end
  def lookup_from_pattern(pattern, element); end
  def project(enumerable, by, get_patterns); end
  def slice(sorted, limit); end
  def sort(key, *redis_options_array); end
  def sort_by(projected, direction); end
end
class FakeRedis::SortedSetArgumentHandler
  def aggregate; end
  def aggregate=(str); end
  def handle(item); end
  def handle_aggregate(item); end
  def handle_weights(item); end
  def initialize(args); end
  def inject_block; end
  def keys; end
  def keys=(arg0); end
  def number_of_keys; end
  def number_of_keys=(arg0); end
  def type; end
  def type=(arg0); end
  def weights; end
  def weights=(arg0); end
end
class FakeRedis::SortedSetStore
  def aggregate; end
  def aggregate=(arg0); end
  def aggregate_max(out); end
  def aggregate_min(out); end
  def aggregate_sum(out); end
  def call; end
  def computed_values; end
  def data; end
  def data=(arg0); end
  def hashes; end
  def initialize(params, data); end
  def keys; end
  def keys=(arg0); end
  def selected_keys; end
  def weights; end
  def weights=(arg0); end
end
class FakeRedis::SortedSetIntersectStore < FakeRedis::SortedSetStore
  def selected_keys; end
end
class FakeRedis::SortedSetUnionStore < FakeRedis::SortedSetStore
  def selected_keys; end
end
module FakeRedis::TransactionCommands
  def discard; end
  def exec; end
  def multi; end
  def self.included(klass); end
  def unwatch; end
  def watch(*_); end
end
class FakeRedis::ZSet < Hash
  def []=(key, val); end
  def _floatify(str, increment = nil); end
  def identical_scores?; end
  def increment(key, val); end
  def select_by_score(min, max); end
end
module FakeRedis::BitopCommand
  def apply(operator, keys); end
  def bitop(operation, destkey, *keys); end
  def bitwise_not(key); end
  def bitwise_operation(operation, keys); end
  def operator(operation); end
end
class Redis
end
module Redis::Connection
end
class Redis::Connection::Memory
  def [](key); end
  def []=(key, value); end
  def append(key, value); end
  def auth(password); end
  def bgrewriteaof; end
  def bgsave; end
  def bitcount(key, start_index = nil, end_index = nil); end
  def blpop(keys, timeout = nil); end
  def brpop(keys, timeout = nil); end
  def brpoplpush(key1, key2, opts = nil); end
  def client(command, _options = nil); end
  def connect_unix(path, timeout); end
  def connected?; end
  def data; end
  def data_type_check(key, klass); end
  def database_id; end
  def database_id=(arg0); end
  def database_instance_key; end
  def databases; end
  def dbsize; end
  def decr(key); end
  def decrby(key, by); end
  def del(*keys); end
  def disconnect; end
  def dump(key); end
  def echo(string); end
  def exists(key); end
  def expire(key, ttl); end
  def expireat(key, timestamp); end
  def find_database(id = nil); end
  def flatten?(param); end
  def flushall; end
  def flushdb; end
  def get(key); end
  def get_limit(opts, vals); end
  def get_range(start, stop, min = nil, max = nil); end
  def getbit(key, offset); end
  def getrange(key, start, ending); end
  def getset(key, value); end
  def hdel(key, field); end
  def hexists(key, field); end
  def hget(key, field); end
  def hgetall(key); end
  def hincrby(key, field, increment); end
  def hincrbyfloat(key, field, increment); end
  def hkeys(key); end
  def hlen(key); end
  def hmget(key, *fields); end
  def hmset(key, *fields); end
  def hscan(key, start_cursor, *args); end
  def hset(key, field, value); end
  def hsetnx(key, field, value); end
  def hvals(key); end
  def in_multi; end
  def in_multi=(multi_state); end
  def incr(key); end
  def incrby(key, by); end
  def incrbyfloat(key, by); end
  def info; end
  def initialize(options = nil); end
  def keys(pattern = nil); end
  def lastsave; end
  def lindex(key, index); end
  def linsert(key, where, pivot, value); end
  def llen(key); end
  def lpop(key); end
  def lpush(key, value); end
  def lpushx(key, value); end
  def lrange(key, startidx, endidx); end
  def lrem(key, count, value); end
  def lset(key, index, value); end
  def ltrim(key, start, stop); end
  def mapped_param?(param); end
  def mget(*keys); end
  def monitor; end
  def move(key, destination_id); end
  def mset(*pairs); end
  def msetnx(*pairs); end
  def options; end
  def options=(arg0); end
  def persist(key); end
  def pexpire(key, ttl); end
  def ping; end
  def psubscribe(*patterns); end
  def pttl(key); end
  def publish(channel, message); end
  def punsubscribe(*patterns); end
  def queued_commands; end
  def queued_commands=(cmds); end
  def quit; end
  def raise_argument_error(command, match_string = nil); end
  def raise_syntax_error; end
  def randomkey; end
  def read; end
  def remove_key_for_empty_collection(key); end
  def rename(key, new_key); end
  def renamenx(key, new_key); end
  def replies; end
  def replies=(arg0); end
  def restore(key, ttl, serialized_value); end
  def rpop(key); end
  def rpoplpush(key1, key2); end
  def rpush(key, value); end
  def rpushx(key, value); end
  def sadd(key, value); end
  def save; end
  def scan(start_cursor, *args); end
  def scard(key); end
  def sdiff(key1, *keys); end
  def sdiffstore(destination, key1, *keys); end
  def select(index); end
  def self.channels; end
  def self.connect(options = nil); end
  def self.databases; end
  def self.in_multi; end
  def self.queued_commands; end
  def self.reset_all_channels; end
  def self.reset_all_databases; end
  def set(key, value, *array_options); end
  def setbit(key, offset, bit); end
  def setex(key, seconds, value); end
  def setnx(key, value); end
  def setrange(key, offset, value); end
  def shutdown; end
  def sinter(*keys); end
  def sinterstore(destination, *keys); end
  def sismember(key, value); end
  def slaveof(host, port); end
  def smembers(key); end
  def smove(source, destination, value); end
  def sort_keys(arr); end
  def spop(key, count = nil); end
  def srandmember(key, number = nil); end
  def srandmember_multiple(key, number); end
  def srandmember_single(key); end
  def srem(key, value); end
  def sscan(key, start_cursor, *args); end
  def strlen(key); end
  def subscribe(*channels); end
  def substr(key, start, ending); end
  def sunion(*keys); end
  def sunionstore(destination, *keys); end
  def sync; end
  def time; end
  def timeout=(usecs); end
  def ttl(key); end
  def type(key); end
  def unsubscribe(*channels); end
  def zadd(key, *args); end
  def zcard(key); end
  def zcount(key, min, max); end
  def zincrby(key, num, value); end
  def zinterstore(out, *args); end
  def zrange(key, start, stop, with_scores = nil); end
  def zrangebylex(key, start, stop, *opts); end
  def zrangebyscore(key, min, max, *opts); end
  def zrank(key, value); end
  def zrem(key, value); end
  def zremrangebyrank(key, start, stop); end
  def zremrangebyscore(key, min, max); end
  def zrevrange(key, start, stop, with_scores = nil); end
  def zrevrangebylex(key, start, stop, *args); end
  def zrevrangebyscore(key, max, min, *opts); end
  def zrevrank(key, value); end
  def zscan(key, start_cursor, *args); end
  def zscan_each(key, *args, &block); end
  def zscore(key, value); end
  def zunionstore(out, *args); end
  include FakeRedis
  include FakeRedis::BitopCommand
  include FakeRedis::CommandExecutor
  include FakeRedis::SortMethod
  include FakeRedis::TransactionCommands
  include Redis::Connection::CommandHelper
end
