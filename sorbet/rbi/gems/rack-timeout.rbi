# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rack-timeout/all/rack-timeout.rbi
#
# rack-timeout-0.5.1
module Rack
end
class Rack::Timeout
  def call(env); end
  def initialize(app, service_timeout: nil, wait_timeout: nil, wait_overtime: nil, service_past_wait: nil); end
  def read_timeout_property(value, default); end
  def self._read_x_request_start(env); end
  def self._request_has_body?(env); end
  def self._set_state!(env, state); end
  def self.notify_state_change_observers(env); end
  def self.register_state_change_observer(id, &callback); end
  def self.unregister_state_change_observer(id); end
  def service_past_wait; end
  def service_timeout; end
  def wait_overtime; end
  def wait_timeout; end
  include Rack::Timeout::MonotonicTime
end
module Rack::Timeout::MonotonicTime
  def fsecs; end
  def fsecs_java; end
  def fsecs_mono; end
  def fsecs_ruby; end
  extend Rack::Timeout::MonotonicTime
end
class Rack::Timeout::Scheduler
  def delay(event, secs); end
  def initialize; end
  def join; end
  def run_every(seconds, &block); end
  def run_in(secs, &block); end
  def run_loop!; end
  def runner; end
  def schedule(event); end
  def self.delay(*a, &b); end
  def self.join(*a, &b); end
  def self.run_every(*a, &b); end
  def self.run_in(*a, &b); end
  def self.schedule(*a, &b); end
  def self.singleton; end
  include Rack::Timeout::MonotonicTime
end
class Anonymous_Struct_30 < Struct
  def monotime; end
  def monotime=(_); end
  def proc; end
  def proc=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Rack::Timeout::Scheduler::RunEvent < Anonymous_Struct_30
  def cancel!; end
  def cancelled?; end
  def initialize(*args); end
  def run!; end
end
class Rack::Timeout::Scheduler::RepeatEvent < Rack::Timeout::Scheduler::RunEvent
  def initialize(monotime, proc, every); end
  def run!; end
end
class Rack::Timeout::Scheduler::Timeout
  def initialize(&on_timeout); end
  def self.timeout(secs, &block); end
  def timeout(secs, &block); end
end
class Rack::Timeout::Scheduler::Timeout::Error < RuntimeError
end
module Rack::Timeout::ExceptionWithEnv
  def env; end
  def initialize(env); end
end
class Rack::Timeout::Error < RuntimeError
  include Rack::Timeout::ExceptionWithEnv
end
class Rack::Timeout::RequestExpiryError < Rack::Timeout::Error
end
class Rack::Timeout::RequestTimeoutError < Rack::Timeout::Error
end
class Rack::Timeout::RequestTimeoutException < Exception
  include Rack::Timeout::ExceptionWithEnv
end
class Rack::Timeout::RequestDetails < Struct
  def id; end
  def id=(_); end
  def ms(k); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def service; end
  def service=(_); end
  def state; end
  def state=(_); end
  def timeout; end
  def timeout=(_); end
  def wait; end
  def wait=(_); end
end
class Rack::Timeout::StateChangeLoggingObserver
  def callback; end
  def initialize; end
  def log_state_change(env); end
  def logger(env = nil); end
  def logger=(arg0); end
  def self.mk_logger(device, level = nil); end
end
module Rack::Timeout::Logger
  def device; end
  def device=(new_device); end
  def disable; end
  def init; end
  def level; end
  def level=(new_level); end
  def logger; end
  def logger=(new_logger); end
  def update(new_device, new_level); end
  extend Rack::Timeout::Logger
end
class Rack::Timeout::Railtie < Rails::Railtie
end
